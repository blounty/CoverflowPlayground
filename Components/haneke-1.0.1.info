{"Name":"Haneke","Id":1415,"Alias":"haneke","Description":"# HanekeComponent details\n\n\n\nA lightweight zero-config image cache for Xamarin iOS.\n\nHaneke resizes images and caches the result on memory and disk. Everything is done in background, allowing for fast, responsive scrolling. Asking Haneke to load, resize, cache and display an *appropriately sized image* is as simple as:\n\n\tImageView.SetImage(url);\n\n_Really._\n","Version":"1.0.1","Summary":"A lightweight zero-config image cache for iOS","QuickStart":"# Getting Started with HanekeComponent\n\n\n\nA lightweight zero-config image cache for Xamarin iOS.\n\nHaneke resizes images and caches the result on memory and disk. Everything is done in background, allowing for fast, responsive scrolling. Asking Haneke to load, resize, cache and display an *appropriately sized image* is as simple as:\n\n\n\tImageView.SetImage(url);\n\n\n_Really._\n\n##Features\n\n* First-level memory cache using `NSCache`.\n* Second-level LRU disk cache using the file system.\n* Zero-config `UIImageView` category to use the cache, optimized for `UITableView` and `UICollectionView` cell reuse.\n* Asynchronous and synchronous image retrieval.\n* Background image resizing and file reading.\n* Image decompression.\n* Custom image transformations before and after resizing.\n* Thread-safe.\n* Automatic cache eviction on memory warnings or disk capacity reached.\n* Preloading images from the disk cache into memory on startup.\n\n##UIImageView extension\n\nHaneke provides convenience methods for `UIImageView` with optimizations for `UITableView` and `UICollectionView` cell reuse. Images will be resized appropriately and cached in a shared cache.\n\n\n\t// Setting a remote image\n\tImageView.SetImage(url);\n\n\t// Setting a local image\n\tImageView.SetImage(path);\n\n\t// Setting an image manually. Requires you to provide a key.\n\tImageView.SetImage(image, key);\n\nThe above lines take care of:\n\n1. If cached, retrieving an appropriately sized image (based on the `bounds` and `contentMode` of the `UIImageView`) from the memory or disk cache. Disk access is performed in background.\n2. If not cached, loading the original image from web/disk/memory and producing an appropriately sized image, both in background. Remote images will be retrieved from the shared `NSURLCache` if available.\n3. Setting the image and animating the change if appropriate.\n4. Or doing nothing if the `UIImageView` was reused during any of the above steps.\n5. Caching the resulting image.\n6. If needed, evicting the least recently used images in the cache.\n\n\n##Cache formats\n\nThe cache behavior can be customized by defining cache formats. Each image view has a default format and you can also define your own formats. A format is uniquely identified by its name.\n\n### UIImageView format\n\nEach image view has a default format created on demand. The default format is configured as follows:\n\n* Size matches the `bounds` of the image view.\n* Images will be scaled based on the `contentMode` of the the image view.\n* Images can be upscaled if they\u0027re smaller than the image view.\n* High compression quality.\n* No preloading.\n* Up to 10MB of disk cache.\n\nModifying this default format is discouraged. Instead, you can set your own custom format like this:\n\n\tHNKCacheFormat format = (HNKCacheFormat)HNKCache.SharedCache().Formats[\"thumbnail\"];\n            if (format == null)\n            {\n                format = new HNKCacheFormat(\"thumbnail\")\n                    {\n                        Size = new SizeF(320, 240),\n                        ScaleMode = HNKScaleMode.AspectFill,\n                        CompressionQuality = 0.5f,\n                        DiskCapacity = 1 * 1024 * 1024,\n                        PreloadPolicy = HNKPreloadPolicy.LastSession\n                    };\n            }\n\t\t\tHanekeImageView.SetCacheFormat(format);\n\n\nTo apply the same custom format to various image views you must use the same format instance. The above example does this by initializing the custom format only if it\u0027s not already registered in the shared cache. In the last line, the image view category takes care of registering the format in the shared cache if needed.\n\n### Disk cache\n\nA format can have disk cache by setting the `diskCapacity` property with a value greater than 0. Haneke will take care of evicting the least recently used images of the format from the disk cache when the disk capacity is surpassed.\n\n### Preload policy\n\nWhen registering a format, Haneke will load none, some or all images cached on disk into the memory cache based on the preload policy of the format. The available preload policies are:\n\n* `PolicyNone`: No images will be preloaded.\n* `PolicyLastSession`: Only images from the last session will be preloaded.\n* `PolicyAll`: All images will be preloaded.\n\nIf an image of the corresponding format is requested before preloading finishes, Haneke will cancel preloading to give priority to the request. To make the most of this feature it\u0027s recommended to register formats on startup.\n\nPreloading only applies to formats that have disk cache.\n\n##Requirements\n\nHaneke requires iOS 7.0 or above. \n","Hash":"54cfcf1286a3db78162448072817437c","TargetPlatforms":["ios"],"TrialHash":null}